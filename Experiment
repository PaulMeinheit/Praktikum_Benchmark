import numpy as np
class Experiment:
    def __init__(self, approximators, function):
        self.approximators = approximators
        self.function = function

    def run(self):
        x_fine = np.linspace(self.function.xdomainstart, self.function.xdomainend, 100)
        y_fine = np.linspace(self.function.ydomainstart, self.function.ydomainend, 100)
        X, Y = np.meshgrid(x_fine, y_fine)

        # Plot original function
        Z_true = self.function.evaluate(X, Y)
        fig = plt.figure()
        ax = fig.add_subplot(111, projection='3d')
        ax.plot_surface(X, Y, Z_true, cmap='plasma')
        ax.set_title("Original Function")
        ax.set_xlabel('x')
        ax.set_ylabel('y')
        ax.set_zlabel('z')
        plt.show()

        # Plot each approximator
        resultList = []
        for i, approximator in enumerate(self.approximators):
            approximator.train(self.function)
            Z_fine = approximator.predict(X, Y)
            resultList.append(Z_fine)

            # Compute Mean Squared Error
            mse = np.mean((Z_true - Z_pred) ** 2)

            # Plot
            fig = plt.figure()
            ax = fig.add_subplot(111, projection='3d')
            ax.plot_surface(X, Y, Z_pred, cmap='viridis')
            ax.set_title(f'Approximator {i+1} (MSE: {mse:.4f})')
            ax.set_xlabel('x')
            ax.set_ylabel('y')
            ax.set_zlabel('z')
            plt.show()
            
        return resultList
    



